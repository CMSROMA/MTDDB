from mtdConstructionDBTools import mtdcdb
import pandas as pd
import getopt
import sys
import time
import re

debug   = False
dryrun  = False
source  = 'TOFPET'
csvHead = 'runName'

shrtOpts = 'hdf:tap'
longOpts = ['help', 'debug', 'file=', 'tofpet', 'array', 'pmt']
helpOpts = ['shows this help',
            'activate debug mode (automatically set a dryrun)',
            'sets the csv filename to read from',
            'sets the source of data as tofpet (default)',
            'sets the source of data as array',
            'sets the source of data as PMT'
            ]

hlp = ('Reads a CSV file generated by a device for LY measurement and\n'
       'transfer data to the dbloader for storing them on the DB\n\n'
       'In order to ship data to CERN, you need to setup a tunnel as follows:\n'
       'ssh -L 50022:dbloader-mtd.cern.ch:22 <your-cern-username>@lxplus.cern.ch')

filename = '~/Downloads/crystalsDB_LYBench_PMT.csv'
filename = '~/Downloads/lyDB_SiPM_Array.csv'
filename = '~/Downloads/lyDB_SiPM_Tofpet.csv'
filename = './fake_Tofpet.csv'

try:
    opts, args = getopt.getopt(sys.argv[1:], shrtOpts, longOpts)
except Exception as excptn:
    print("Unexpected exception: " + str(excptn))
    mtdcdb.mtdhelp(shrtOpts, longOpts, helpOpts, -1, hlp)

for o, a in opts:
    if o in ('-h', '--help'):
        mtdcdb.mtdhelp(shrtOpts, longOpts, helpOpts, 0, hlp)
    elif o in ('-f', '--file'):
        filename = a
    elif o in ('-d', '--debug'):
        debug = True
        dryrun = True
    elif o in ('-t', '--tofpet'):
        source = 'TOFPET'
    elif o in ('-p', '--pmt'):
        source = 'PMT'
    elif o in ('-a', '--array'):
        source = 'ARRAY'        

csv = pd.read_csv(filename)

# first get the different runs
runs = csv[csvHead]
runSet = set(runs)

# ssh session management
# add the following line to your .ssh/config file
# ControlPath ~/.ssh/control-%h-%p-%r
if not debug:
    mtdcdb.initiateSession(user='pbarria')
# iterate over runs
for run in runSet:
    # create an XML structure per run
    root = mtdcdb.root()
    filtered_rows = csv.loc[csv[csvHead] == run]
    # extract the begin time of a run from its tag, if 
    run_begin = None
    m = re.search('_[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}', run)
 
    if m:
        run_begin = m.group(0)
        run_begin = re.sub('_', '', run_begin)
        run_begin = re.sub('-([0-9]{2})-([0-9]{2})-([0-9]{2})$', ' \\1:\\2:\\3', run_begin)

    # build the dictionary with data
    xdataset = {}
    for index, row in filtered_rows.iterrows():
        if source == 'PMT':
            run_begin = row['time']
            print(run_begin)
            run_begin = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(run_begin))
        parttype = row['type']
        barcode = str(row['id'])
        # get the barcode: if it is in the form FK% it has been already formatted
        #                  otherwise, if it is a plain, short, integer, we need to
        #                  format it. For preproduction parts we prepend the string
        #                  PRE to the barcode
        if not 'FK' in barcode:
            barcode = 'PRE{:010d}'.format(int(row['id']))
        # if this is an array, the barcode is composed from the barcode of the array
        # followed by the bar index
        if parttype == 'array':
            barcode += '-' + str(row['bar'])
        lyAbs = row['ly']
        lyNorm = lyAbs/row['lyRef']
        xdata = []
        if source == 'PMT':
            b_rms = row['b_rms']
            b_3s_asym = row['b_3s_asym']
            b_2s_asym = row['b_2s_asym']
            decay_time = row['decay_time']
            xdata = [{'NAME': 'B_RMS',      'VALUE': b_rms},
                     {'NAME': 'B_3S_ASYM',  'VALUE': b_3s_asym},
                     {'NAME': 'B_2S_ASYM',  'VALUE': b_2s_asym},
                     {'NAME': 'LY_ABS',     'VALUE': lyAbs},
                     {'NAME': 'DECAY_TIME', 'VALUE': decay_time},
                     {'NAME': 'LY_NORM',    'VALUE': lyNorm}]
        else:
            ctr = row['ctr']
            ctr_norm = ctr/row['ctrRef']
            sigma_t = row['sigmaT']
            sigma_t_norm = sigma_t/row['sigmaTRef']
            temperature = row['temp']
            xtLeft = row['xtLeft']
            xtRight = row['xtRight']
            xdata = [{'NAME': 'CTR',          'VALUE': ctr},
                     {'NAME': 'CTR_NORM',     'VALUE': ctr_norm},
                     {'NAME': 'TEMPERATURE',  'VALUE': temperature},
                     {'NAME': 'XTLEFT',       'VALUE': xtLeft},
                     {'NAME': 'XTRIGHT',      'VALUE': xtRight},
                     {'NAME': 'LY',           'VALUE': lyAbs},                     
                     {'NAME': 'LY_NORM',      'VALUE': lyNorm},
                     {'NAME': 'SIGMA_T',      'VALUE': sigma_t},
                     {'NAME': 'SIGMA_T_NORM', 'VALUE': sigma_t_norm}]
        xdataset[barcode] = xdata
    #create the run    
    run_dict = { 'NAME': run,
                 'TYPE': source,
                 'NUMBER': -1,
                 'COMMENT': '',
                 'LOCATION': 'Roma/' + source
        }
    # create the condition
    condName = 'LY XTALK'
    if source == 'PMT':
        condName = 'LY MEASUREMENT'
    condition = mtdcdb.newCondition(root, condName, xdataset, run = run_dict,
                                    runBegin = run_begin)
    # dump the XML file
    mtdcdb.transfer(condition, dryrun = dryrun,user='pbarria')
    if debug:
        print(mtdcdb.mtdxml(condition))
    
if not debug:
    mtdcdb.terminateSession(user='pbarria')

